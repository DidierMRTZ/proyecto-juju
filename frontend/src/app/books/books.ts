
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import { FormsModule } from '@angular/forms';

interface Book {
  bookId: string;  // Cambiado de _id a bookId
  title: string;
  author: string;
  publicationYear: number;
  status: 'available' | 'reserved';
  createdAt?: string;
  updatedAt?: string;
}

@Component({
  selector: 'app-books',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './books.html',
  styleUrl: './books.css'
})
export class BooksComponent implements OnInit {
  books: Book[] = [];
  filteredBooks: Book[] = []; // Libros filtrados
  isLoading = false;
  error = '';
  totalCount = 0;
  
  // Propiedades para el modal
  showModal = false;
  selectedBook: Book | null = null;
  
  // Propiedades para el modo de edici√≥n
  isEditing = false;
  editingBook: Book | null = null;

  // Propiedades para crear libro
  showCreateModal = false;
  newBook: Partial<Book> = {
    title: '',
    author: '',
    publicationYear: new Date().getFullYear(),
    status: 'available'
  };

  // Propiedades para filtros
  currentFilter: 'all' | 'available' | 'reserved' = 'all';
  filterButtons: Array<{
    key: 'all' | 'available' | 'reserved';
    label: string;
    icon: string;
  }> = [
    { key: 'all', label: 'üìö Todos', icon: 'üìö' },
    { key: 'available', label: '‚úÖ Disponibles', icon: '‚úÖ' },
    { key: 'reserved', label: 'üîí Reservados', icon: 'üîí' }
  ];

  // Propiedades para b√∫squeda por t√≠tulo
  searchTitle: string = '';
  isSearching: boolean = false;
  searchResults: Book[] = [];

  constructor(
    private http: HttpClient,
    private router: Router
  ) {}

  ngOnInit() {
    console.log('BooksComponent inicializado');
    if (typeof window === 'undefined') {
      console.log('No ejecutando en modo SSR, saltando inicializaci√≥n del navegador');
      return;
    }
    
    // Verificar autenticaci√≥n antes de cargar
    this.checkAuthentication();
  }

  // Verificar si el usuario est√° autenticado
  private checkAuthentication() {
    const token = localStorage.getItem('token');
    if (!token) {
      console.warn('No hay token, redirigiendo a login');
      this.router.navigate(['/login']);
      return;
    }

    console.log('Token encontrado, verificando validez...');
    
    // Verificar que el token sea v√°lido antes de cargar
    this.validateTokenAndLoad(token);
  }

  // Validar token y cargar libros si es v√°lido
  private validateTokenAndLoad(token: string) {
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    console.log('Validando token contra la API...');
    
    this.http.get('http://localhost:3000/api/books', { headers })
      .subscribe({
        next: (response: any) => {
          console.log('Token v√°lido, cargando libros...');
          this.viewBooks(); // Auto-debug on init
          
          // Cargar libros autom√°ticamente
          setTimeout(() => {
            console.log('Probando API autom√°ticamente al cargar...');
            this.testAPIOnInit();
          }, 100);
        },
        error: (error) => {
          console.error('Token inv√°lido o error de API:', error);
          
          if (error.status === 401) {
            console.warn('Token inv√°lido, limpiando y redirigiendo...');
            this.clearUserData();
            this.router.navigate(['/login']);
          } else {
            console.error('Error de API:', error);
            this.error = 'Error de conexi√≥n con la API';
          }
        }
      });
  }

  // Limpiar datos del usuario
  private clearUserData() {
    localStorage.removeItem('token');
    localStorage.removeItem('userEmail');
    localStorage.removeItem('userRole');
    console.log('Datos de usuario limpiados');
  }

  // M√©todo para probar la API autom√°ticamente al inicializarse
  testAPIOnInit() {
    console.log('Probando API de libros autom√°ticamente...');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('No ejecutando en modo SSR, saltando testAPIOnInit');
      return;
    }

    // Obtener token del localStorage
    const token = localStorage.getItem('token');
    if (!token) {
      console.warn('No hay token en localStorage, redirigiendo a login');
      this.router.navigate(['/login']);
      return;
    }

    console.log('Token encontrado, configurando headers de autenticaci√≥n...');
    
    // Configurar headers con el token
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    console.log('Headers configurados:', headers);
    console.log('Haciendo petici√≥n GET a http://localhost:3000/api/books');

    this.isLoading = true;
    this.error = '';

    // Configurar timeout de 8 segundos
    const timeoutId = setTimeout(() => {
      console.log('Timeout de 8 segundos alcanzado');
      this.isLoading = false;
      this.error = '‚è∞ Timeout: La API no respondi√≥ en 8 segundos';
    }, 8000);

    this.http.get('http://localhost:3000/api/books', { headers })
      .subscribe({
        next: (response: any) => {
          clearTimeout(timeoutId);
          console.log('Respuesta exitosa de la API:', response);
          
          if (response.success && response.data && response.data.books) {
            this.books = response.data.books;
            this.totalCount = response.data.count;
            console.log(`${this.books.length} libros cargados exitosamente`);
            
            // Aplicar filtro inicial
            this.applyFilter(this.currentFilter);
            
            // Verificar estructura de IDs
            console.log('=== VERIFICACI√ìN DE IDs ===');
            this.books.forEach((book, index) => {
              console.log(`Libro ${index + 1}:`, {
                title: book.title,
                id: book.bookId,
                idType: typeof book.bookId,
                idLength: book.bookId?.length,
                hasId: !!book.bookId
              });
            });
          } else {
            console.warn('‚ö†Ô∏è Respuesta inesperada de la API:', response);
            this.error = 'Respuesta inesperada de la API';
          }
          
          this.isLoading = false;
        },
        error: (error) => {
          clearTimeout(timeoutId);
          console.error('‚ùå Error en la API:', error);
          
          let errorMessage = 'Error al cargar libros';
          
          if (error.status === 0) {
            errorMessage = '‚ùå No se puede conectar al servidor. ¬øEst√° corriendo en http://localhost:3000?';
          } else if (error.status === 401) {
            errorMessage = '‚ùå No autorizado. Token inv√°lido o expirado.';
            console.warn('üîë Token inv√°lido, redirigiendo a login...');
            setTimeout(() => {
              this.router.navigate(['/login']);
            }, 2000);
          } else if (error.status === 403) {
            errorMessage = '‚ùå Acceso prohibido. No tienes permisos para ver libros.';
          } else if (error.status === 404) {
            errorMessage = '‚ùå Endpoint no encontrado. Verifica la URL de la API.';
          } else if (error.status === 500) {
            errorMessage = '‚ùå Error interno del servidor. Intenta m√°s tarde.';
          } else {
            errorMessage = `‚ùå Error ${error.status}: ${error.message || 'Error desconocido'}`;
          }
          
          this.error = errorMessage;
          this.isLoading = false;
        }
      });
  }

  // M√©todo para cancelar la edici√≥n
  cancelEdit() {
    console.log('Cancelando edici√≥n del libro');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('No ejecutando en modo SSR, saltando cancelEdit');
      return;
    }
    
    this.isEditing = false;
    this.editingBook = null;
    
    console.log('=== ESTADO DESPU√âS DE CANCELAR EDICI√ìN ===');
    console.log('isEditing:', this.isEditing);
    console.log('editingBook:', this.editingBook);
    console.log('============================');
  }

  // M√©todos para crear libro
  showCreateBookModal() {
    console.log('‚ûï Abriendo modal para crear libro...');
    this.showCreateModal = true;
    this.resetNewBook();
  }

  closeCreateModal() {
    console.log('Cerrando modal de creaci√≥n...');
    this.showCreateModal = false;
    this.resetNewBook();
  }

  resetNewBook() {
    this.newBook = {
      title: '',
      author: '',
      publicationYear: new Date().getFullYear(),
      status: 'available'
    };
  }

  createBook() {
    if (!this.newBook.title || !this.newBook.author || !this.newBook.publicationYear) {
      console.warn('‚ö†Ô∏è Campos requeridos incompletos');
      alert('Por favor completa todos los campos requeridos');
      return;
    }

    console.log('üìù Creando nuevo libro:', this.newBook);
    
    const token = localStorage.getItem('token');
    if (!token) {
      console.error('‚ùå No hay token de autenticaci√≥n');
      this.error = 'No tienes permisos para crear libros';
      return;
    }

    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    this.isLoading = true;
    this.error = '';

    this.http.post('http://localhost:3000/api/books', this.newBook, { headers })
      .subscribe({
        next: (response: any) => {
          console.log('Libro creado exitosamente:', response);
          this.isLoading = false;
          this.closeCreateModal();
          
          // Recargar la lista de libros
          setTimeout(() => {
            this.testAPIOnInit();
          }, 500);
          
          // Mostrar mensaje de √©xito
          alert(`‚úÖ Libro "${this.newBook.title}" creado exitosamente`);
        },
        error: (error) => {
          console.error('‚ùå Error creando libro:', error);
          this.isLoading = false;
          
          if (error.status === 401) {
            this.error = '‚ùå No tienes permisos para crear libros';
            this.clearUserData();
            this.router.navigate(['/login']);
          } else if (error.status === 400) {
            this.error = '‚ùå Datos inv√°lidos: ' + (error.error?.message || 'Verifica los campos');
          } else {
            this.error = '‚ùå Error del servidor: ' + (error.error?.message || 'Intenta de nuevo');
          }
        }
      });
  }

  loadBooks() {
    console.log('üîÑ M√©todo loadBooks() ejecutado manualmente');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando loadBooks');
      return;
    }
    
    // Debug del estado antes de cargar
    console.log('üîÑ === ESTADO ANTES DE CARGA MANUAL ===');
    this.viewBooks();
    
    this.isLoading = true;
    this.error = '';
    
    // Usar el mismo m√©todo autom√°tico
    this.testAPIOnInit();
  }

  getStatusText(status: string): string {
    return status === 'available' ? 'Disponible' : 'Reservado';
  }

  getStatusClass(status: string): string {
    return status === 'available' ? 'status-available' : 'status-reserved';
  }

  logout() {
    console.log('üö™ Cerrando sesi√≥n...');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando logout');
      return;
    }

    // Limpiar todos los datos del usuario
    this.clearUserData();
    
    // Limpiar estado del componente
    this.books = [];
    this.totalCount = 0;
    this.error = '';
    this.isLoading = false;
    this.showModal = false;
    this.selectedBook = null;
    this.isEditing = false;
    this.editingBook = null;
    
    console.log('üßπ Estado del componente limpiado');
    
    // Redirigir a login
    console.log('üöÄ Redirigiendo a /login...');
    this.router.navigate(['/login']);
  }

  testButton() {
    console.log('üß™ Bot√≥n de prueba clickeado!');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando testButton');
      return;
    }
    
    alert('¬°El bot√≥n funciona! Ahora probando loadBooks...');
    this.loadBooks();
  }

  testAPI() {
    console.log('üîó Probando API directamente...');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando testAPI');
      return;
    }
    
    // Hacer una petici√≥n simple a la API
    this.http.get('http://localhost:3000/api/books')
      .subscribe({
        next: (response) => {
          console.log('‚úÖ API responde correctamente:', response);
          alert('‚úÖ API funciona! Respuesta: ' + JSON.stringify(response).substring(0, 100) + '...');
        },
        error: (error) => {
          console.error('‚ùå API no responde:', error);
          alert('‚ùå API no responde: ' + error.message);
        }
      });
  }

  // M√©todo para limpiar estados y forzar recarga
  forceReload() {
    console.log('üö® Forzando recarga completa...');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando forceReload');
      return;
    }
    
    // Debug del estado antes de limpiar
    console.log('üßπ === ESTADO ANTES DE LIMPIAR ===');
    this.viewBooks();
    
    // Limpiar todos los estados
    this.isLoading = false;
    this.error = '';
    this.books = [];
    this.totalCount = 0;
    
    // Forzar detecci√≥n de cambios
    console.log('üßπ Estados limpiados, forzando recarga...');
    
    // Debug del estado despu√©s de limpiar
    console.log('üßπ === ESTADO DESPU√âS DE LIMPIAR ===');
    this.viewBooks();
    
    // Esperar un momento y luego cargar
    setTimeout(() => {
      console.log('üîÑ Iniciando recarga forzada...');
      this.testAPIOnInit();
    }, 200);
  }

  // M√©todos para obtener informaci√≥n del usuario
  getUserEmail(): string {
    if (typeof window !== 'undefined' && window.localStorage) {
      return localStorage.getItem('userEmail') || 'No disponible';
    }
    return 'No disponible (SSR)';
  }

  getUserRole(): string {
    if (typeof window !== 'undefined' && window.localStorage) {
      return localStorage.getItem('userRole') || 'No disponible';
    }
    return 'No disponible (SSR)';
  }

  // M√©todo helper para convertir string a tipo de filtro v√°lido
  private getFilterType(key: string): 'all' | 'available' | 'reserved' {
    if (key === 'all' || key === 'available' || key === 'reserved') {
      return key;
    }
    return 'all'; // valor por defecto
  }

  // Aplicar filtro
  applyFilter(filterType: 'all' | 'available' | 'reserved') {
    console.log(`Aplicando filtro: ${filterType}`);
    
    // Limpiar b√∫squeda cuando se cambia de filtro
    if (this.searchTitle.trim()) {
      this.clearSearch();
    }
    
    this.currentFilter = filterType;
    
    if (filterType === 'all') {
      this.filteredBooks = [...this.books];
    } else {
      this.filteredBooks = this.books.filter(book => book.status === filterType);
    }
    
    console.log(`Filtro aplicado: ${filterType}, libros mostrados: ${this.filteredBooks.length}`);
  }

  // M√©todo para obtener el contador de libros por filtro
  getFilterCount(filter: string): number {
    const filterType = this.getFilterType(filter);
    
    switch (filterType) {
      case 'all':
        return this.books.length;
      case 'available':
        return this.books.filter(book => book.status === 'available').length;
      case 'reserved':
        return this.books.filter(book => book.status === 'reserved').length;
      default:
        return 0;
    }
  }

  // M√©todo helper para obtener la etiqueta del filtro
  getFilterLabel(filter: string): string {
    const filterType = this.getFilterType(filter);
    
    switch (filterType) {
      case 'all':
        return 'Todos';
      case 'available':
        return 'Disponibles';
      case 'reserved':
        return 'Reservados';
      default:
        return 'Todos';
    }
  }

  // M√©todo para debug del estado actual
  viewBooks() {
    console.log('üîç === ESTADO ACTUAL DEL COMPONENTE ===');
    console.log('üìÖ Timestamp:', new Date().toISOString());
    console.log('üîÑ isLoading:', this.isLoading);
    console.log('‚ùå error:', this.error);
    console.log('üìö books.length:', this.books.length);
    console.log('üìä totalCount:', this.totalCount);
    console.log('üîç currentFilter:', this.currentFilter);
    console.log('üìñ filteredBooks.length:', this.filteredBooks.length);
    
    // Informaci√≥n de filtros
    console.log('üîç === INFORMACI√ìN DE FILTROS ===');
    console.log('üìö Total libros:', this.getFilterCount('all'));
    console.log('‚úÖ Libros disponibles:', this.getFilterCount('available'));
    console.log('üîí Libros reservados:', this.getFilterCount('reserved'));
    
    // Verificar si estamos en el navegador antes de acceder a localStorage
    if (typeof window !== 'undefined' && window.localStorage) {
      const token = localStorage.getItem('token');
      const userEmail = localStorage.getItem('userEmail');
      const userRole = localStorage.getItem('userRole');
      
      console.log('üîë localStorage token:', token ? 'S√ç' : 'NO');
      console.log('üë§ Usuario email:', userEmail || 'No disponible');
      console.log('üîë Usuario rol:', userRole || 'No disponible');
      console.log('üåê URL actual:', window.location.href);
      console.log('üì± User Agent:', navigator.userAgent);
      
      // Tambi√©n mostrar en la consola si hay alg√∫n problema
      if (!token) {
        console.warn('‚ö†Ô∏è ADVERTENCIA: No hay token en localStorage');
      }
      if (!userEmail) {
        console.warn('‚ö†Ô∏è ADVERTENCIA: No hay email de usuario en localStorage');
      }
      if (!userRole) {
        console.warn('‚ö†Ô∏è ADVERTENCIA: No hay rol de usuario en localStorage');
      }
    } else {
      console.log('üîë localStorage: No disponible (modo SSR)');
      console.log('üåê URL actual: No disponible (modo SSR)');
      console.log('üì± User Agent: No disponible (modo SSR)');
    }
    
    console.log('=====================================');
    
    if (this.error) {
      console.warn('‚ö†Ô∏è ADVERTENCIA: Hay un error activo:', this.error);
    }
  }

  // M√©todo para debug espec√≠fico del libro seleccionado
  debugSelectedBook() {
    console.log('üìö === INFORMACI√ìN DEL LIBRO SELECCIONADO ===');
    if (this.selectedBook) {
      console.log('üìö Libro seleccionado:', this.selectedBook);
      console.log('üÜî ID:', this.selectedBook.bookId);
      console.log('üìã Tipo del ID:', typeof this.selectedBook.bookId);
      console.log('üìè Longitud del ID:', this.selectedBook.bookId?.length);
      console.log('üìù T√≠tulo:', this.selectedBook.title);
      console.log('‚úçÔ∏è Autor:', this.selectedBook.author);
      console.log('üìÖ A√±o:', this.selectedBook.publicationYear);
      console.log('üè∑Ô∏è Estado:', this.selectedBook.status);
      
      // Verificaci√≥n de integridad del libro seleccionado
      console.log('üîç === VERIFICACI√ìN DE INTEGRIDAD ===');
      console.log('‚úÖ Tiene t√≠tulo:', !!this.selectedBook.title);
      console.log('‚úÖ Tiene autor:', !!this.selectedBook.author);
      console.log('‚úÖ Tiene a√±o:', !!this.selectedBook.publicationYear);
      console.log('‚úÖ Tiene estado:', !!this.selectedBook.status);
      console.log('‚úÖ Tiene ID v√°lido:', !!(this.selectedBook.bookId && this.selectedBook.bookId.length === 24));
    } else {
      console.log('‚ùå No hay libro seleccionado');
    }
    console.log('=====================================');
    
    // Tambi√©n mostrar en alert para f√°cil visualizaci√≥n
    if (this.selectedBook) {
      let bookInfo = `üìö INFORMACI√ìN DEL LIBRO\n\n`;
      bookInfo += `üìù T√≠tulo: ${this.selectedBook.title}\n`;
      bookInfo += `‚úçÔ∏è Autor: ${this.selectedBook.author}\n`;
      bookInfo += `üìÖ A√±o: ${this.selectedBook.publicationYear}\n`;
      bookInfo += `üè∑Ô∏è Estado: ${this.getStatusText(this.selectedBook.status)}\n`;
      bookInfo += `üÜî ID: ${this.selectedBook.bookId}\n`;
      bookInfo += `üìè Longitud ID: ${this.selectedBook.bookId?.length || 0}\n`;
      bookInfo += `‚úÖ ID V√°lido: ${this.selectedBook.bookId && this.selectedBook.bookId.length === 24 ? 'S√ç' : 'NO'}\n`;
      
      if (this.selectedBook.createdAt) {
        bookInfo += `üìÖ Creado: ${new Date(this.selectedBook.createdAt).toLocaleString()}\n`;
      }
      if (this.selectedBook.updatedAt) {
        bookInfo += `üîÑ Actualizado: ${new Date(this.selectedBook.updatedAt).toLocaleString()}\n`;
      }
      
      alert(bookInfo);
    } else {
      alert('‚ùå No hay libro seleccionado para mostrar informaci√≥n');
    }
  }

  // M√©todo para mostrar el modal del libro
  showBookModal(book: Book) {
    console.log('üìö Mostrando modal para libro:', book.title);
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando showBookModal');
      return;
    }
    
    this.selectedBook = book;
    this.showModal = true;
    
    // Debug del estado del modal
    console.log('üîç === ESTADO DEL MODAL ===');
    console.log('showModal:', this.showModal);
    console.log('selectedBook:', this.selectedBook);
    console.log('==========================');
    
    // Debug espec√≠fico del libro seleccionado
    this.debugSelectedBook();
  }

  // M√©todo para cerrar el modal
  closeModal() {
    console.log('‚ùå Cerrando modal del libro');
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando closeModal');
      return;
    }
    
    this.showModal = false;
    this.selectedBook = null;
    this.isEditing = false;
    this.editingBook = null;
    
    // Debug del estado despu√©s de cerrar
    console.log('üîç === ESTADO DESPU√âS DE CERRAR MODAL ===');
    console.log('showModal:', this.showModal);
    console.log('selectedBook:', this.selectedBook);
    console.log('isEditing:', this.isEditing);
    console.log('editingBook:', this.editingBook);
    console.log('==========================================');
  }

  // M√©todo para iniciar la edici√≥n de un libro
  editBook() {
    if (!this.selectedBook) {
      console.log('‚ùå No hay libro seleccionado para editar');
      return;
    }

    console.log('‚úèÔ∏è Iniciando edici√≥n del libro:', this.selectedBook.title);
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando editBook');
      return;
    }

    // Crear una copia del libro para editar
    this.editingBook = {
      bookId: this.selectedBook.bookId,
      title: this.selectedBook.title,
      author: this.selectedBook.author,
      publicationYear: this.selectedBook.publicationYear,
      status: this.selectedBook.status,
      createdAt: this.selectedBook.createdAt,
      updatedAt: this.selectedBook.updatedAt
    };
    
    this.isEditing = true;
    
    console.log('üîç === ESTADO DE EDICI√ìN ===');
    console.log('isEditing:', this.isEditing);
    console.log('editingBook:', this.editingBook);
    console.log('============================');
  }

  // M√©todo para guardar los cambios del libro
  saveBookChanges() {
    if (!this.editingBook) {
      console.log('‚ùå No hay libro en edici√≥n para guardar');
      return;
    }

    console.log('üíæ Guardando cambios del libro:', this.editingBook.title);
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando saveBookChanges');
      return;
    }

    // Validar que los campos requeridos no est√©n vac√≠os
    if (!this.editingBook.title || !this.editingBook.author || !this.editingBook.publicationYear) {
      alert('‚ùå Error: Todos los campos son obligatorios');
      return;
    }

    // Validar que el a√±o sea un n√∫mero v√°lido
    if (isNaN(this.editingBook.publicationYear) || this.editingBook.publicationYear < 1000 || this.editingBook.publicationYear > 2025) {
      alert('‚ùå Error: El a√±o debe ser un n√∫mero entre 1000 y 2025');
      return;
    }

    console.log('üîÑ Enviando cambios a la API...');
    console.log('üåê URL de la petici√≥n:', `http://localhost:3000/api/books/${this.editingBook.bookId}`);
    console.log('üìù Datos a enviar:', this.editingBook);

    // Preparar los datos para enviar (sin bookId, createdAt, updatedAt)
    const updateData = {
      title: this.editingBook.title,
      author: this.editingBook.author,
      publicationYear: this.editingBook.publicationYear,
      status: this.editingBook.status
    };

    // Hacer la petici√≥n PUT a la API
    const token = localStorage.getItem('token');
    if (!token) {
      console.error('‚ùå No hay token disponible para la petici√≥n');
      alert('‚ùå Error: No hay token de autenticaci√≥n');
      return;
    }

    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    console.log('üåê Headers configurados para PUT:', headers);
    console.log('üì§ Datos a enviar:', updateData);

    this.http.put(`http://localhost:3000/api/books/${this.editingBook!.bookId}`, updateData, { headers })
      .subscribe({
        next: (response) => {
          console.log('‚úÖ Libro actualizado exitosamente:', response);
          
          // Actualizar el libro en la lista local
          const bookIndex = this.books.findIndex(b => b.bookId === this.editingBook!.bookId);
          if (bookIndex !== -1) {
            this.books[bookIndex] = { ...this.books[bookIndex], ...updateData };
            this.selectedBook = this.books[bookIndex];
          }
          
          // Actualizar filtros
          this.applyFilter(this.currentFilter);
          
          // Salir del modo de edici√≥n
          this.isEditing = false;
          this.editingBook = null;
          
          // Cerrar el modal autom√°ticamente
          this.closeModal();
          
          // Mostrar mensaje de √©xito
          alert(`‚úÖ Libro "${updateData.title}" actualizado exitosamente`);
          
          // Debug del estado despu√©s de la actualizaci√≥n
          console.log('üíæ === ESTADO DESPU√âS DE LA ACTUALIZACI√ìN ===');
          this.viewBooks();
        },
        error: (error) => {
          console.error('‚ùå Error al actualizar el libro:', error);
          console.error('Status:', error.status);
          console.error('Message:', error.message);
          console.error('URL intentada:', `http://localhost:3000/api/books/${this.editingBook!.bookId}`);
          
          let errorMessage = 'Error al actualizar el libro';
          
          if (error.status === 0) {
            errorMessage = 'No se puede conectar al servidor. ¬øEst√° corriendo en http://localhost:3000?';
          } else if (error.status === 404) {
            errorMessage = 'Libro no encontrado (404). Puede que haya sido borrado.';
          } else if (error.status === 500) {
            errorMessage = 'Error interno del servidor (500). Verifica la consola para m√°s detalles.';
          } else if (error.status === 400) {
            errorMessage = 'Datos incorrectos (400). Verifica que todos los campos sean v√°lidos.';
          } else if (error.status === 403) {
            errorMessage = 'No tienes permisos para actualizar este libro.';
          } else {
            errorMessage = `Error ${error.status}: ${error.message || 'Error desconocido'}`;
          }
          
          alert(`‚ùå ${errorMessage}`);
          
          // Debug del estado despu√©s del error
          console.log('üí• === ESTADO DESPU√âS DEL ERROR DE ACTUALIZACI√ìN ===');
          this.viewBooks();
        }
      });
  }

  // M√©todo para borrar el libro seleccionado
  deleteBook() {
    if (!this.selectedBook) {
      console.log('‚ùå No hay libro seleccionado para borrar');
      return;
    }

    console.log('üóëÔ∏è Borrando libro:', this.selectedBook.title);
    console.log('üÜî ID del libro:', this.selectedBook.bookId);
    console.log('üìã Tipo del ID:', typeof this.selectedBook.bookId);
    
    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('üö´ No ejecutando en modo SSR, saltando deleteBook');
      return;
    }

    // Validar que el ID exista y sea v√°lido
    if (!this.selectedBook.bookId) {
      console.error('‚ùå ID del libro es undefined o null');
      alert('‚ùå Error: ID del libro no v√°lido');
      return;
    }

    // Validar formato del ID (debe ser un string de 24 caracteres hexadecimal)
    if (typeof this.selectedBook.bookId !== 'string' || this.selectedBook.bookId.length !== 24) {
      console.error('‚ùå Formato del ID no v√°lido:', this.selectedBook.bookId);
      alert('‚ùå Error: Formato del ID del libro no v√°lido');
      return;
    }

    // Confirmar antes de borrar
    if (!confirm(`¬øEst√°s seguro de que quieres borrar "${this.selectedBook.title}"? Esta acci√≥n no se puede deshacer.`)) {
      console.log('‚ùå Usuario cancel√≥ el borrado');
      return;
    }

    // Mostrar indicador de carga
    const originalTitle = this.selectedBook.title;
    const bookId = this.selectedBook.bookId;
    console.log('üîÑ Iniciando borrado del libro...');
    console.log('üåê URL de la petici√≥n:', `http://localhost:3000/api/books/${bookId}`);

    // Hacer la petici√≥n DELETE a la API
    const token = localStorage.getItem('token');
    if (!token) {
      console.error('‚ùå No hay token disponible para la petici√≥n');
      alert('‚ùå Error: No hay token de autenticaci√≥n');
      return;
    }

    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    console.log('üåê Headers configurados para DELETE:', headers);

    this.http.delete(`http://localhost:3000/api/books/${bookId}`, { headers })
      .subscribe({
        next: (response) => {
          console.log('‚úÖ Libro borrado exitosamente:', response);
          
          // Remover el libro de la lista local
          this.books = this.books.filter(book => book.bookId !== bookId);
          this.totalCount = this.books.length;
          
          // Actualizar filtros
          this.applyFilter(this.currentFilter);
          
          // Cerrar el modal autom√°ticamente
          this.closeModal();
          
          // Mostrar mensaje de √©xito
          alert(`‚úÖ Libro "${originalTitle}" borrado exitosamente`);
          
          // Debug del estado despu√©s del borrado
          console.log('üóëÔ∏è === ESTADO DESPU√âS DEL BORRADO ===');
          this.viewBooks();
        },
        error: (error) => {
          console.error('‚ùå Error al borrar el libro:', error);
          console.error('Status:', error.status);
          console.error('Message:', error.message);
          console.error('URL intentada:', `http://localhost:3000/api/books/${bookId}`);
          console.error('ID usado:', bookId);
          
          let errorMessage = 'Error al borrar el libro';
          
          if (error.status === 0) {
            errorMessage = 'No se puede conectar al servidor. ¬øEst√° corriendo en http://localhost:3000?';
          } else if (error.status === 404) {
            errorMessage = 'Libro no encontrado (404). Puede que ya haya sido borrado.';
          } else if (error.status === 500) {
            errorMessage = 'Error interno del servidor (500). Verifica la consola para m√°s detalles.';
          } else if (error.status === 403) {
            errorMessage = 'No tienes permisos para borrar este libro.';
          } else if (error.status === 400) {
            errorMessage = 'Datos incorrectos (400). Verifica el ID del libro.';
          } else {
            errorMessage = `Error ${error.status}: ${error.message || 'Error desconocido'}`;
          }
          
          alert(`‚ùå ${errorMessage}`);
          
          // Debug del estado despu√©s del error
          console.log('üí• === ESTADO DESPU√âS DEL ERROR DE BORRADO ===');
          this.viewBooks();
        }
      });
  }

  // M√©todo para buscar libros por t√≠tulo
  searchBooksByTitle() {
    if (!this.searchTitle.trim()) {
      console.log('‚ö†Ô∏è Campo de b√∫squeda vac√≠o, no se puede buscar');
      this.searchResults = [];
      this.isSearching = false;
      return;
    }

    console.log('=== INICIANDO B√öSQUEDA POR API ===');
    console.log('T√©rmino de b√∫squeda:', this.searchTitle);
    console.log('üîç Ejecutando desde bot√≥n de b√∫squeda...');
    
    this.isSearching = true;
    this.searchResults = [];

    // Verificar si estamos en el navegador
    if (typeof window === 'undefined') {
      console.log('No ejecutando en modo SSR, saltando b√∫squeda');
      return;
    }

    // Obtener token del localStorage
    const token = localStorage.getItem('token');
    if (!token) {
      console.warn('No hay token en localStorage, redirigiendo a login');
      this.router.navigate(['/login']);
      return;
    }

    // Configurar headers con el token
    const headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };

    const searchUrl = `http://localhost:3000/api/books/title/${encodeURIComponent(this.searchTitle)}`;
    console.log('URL de b√∫squeda:', searchUrl);

    this.http.get(searchUrl, { headers })
      .subscribe({
        next: (response: any) => {
          console.log('=== RESPUESTA DE B√öSQUEDA POR API ===');
          console.log('Respuesta completa:', response);
          
          this.isSearching = false;
          
          if (response.success && response.data && response.data.books) {
            this.searchResults = response.data.books;
            console.log(`‚úÖ ${this.searchResults.length} libros encontrados por API para "${this.searchTitle}"`);
          } else {
            // Si no hay resultados de la API, intentar b√∫squeda local
            console.log('‚ö†Ô∏è No se encontraron libros con la API, intentando b√∫squeda local...');
            this.performLocalSearch();
          }
        },
        error: (error) => {
          console.error('=== ERROR EN B√öSQUEDA POR API ===');
          console.error('Error completo:', error);
          
          this.isSearching = false;
          
          if (error.status === 401) {
            console.warn('Token inv√°lido, redirigiendo a login');
            this.router.navigate(['/login']);
          } else if (error.status === 404) {
            console.log('No se encontraron libros con ese t√≠tulo en la API, intentando b√∫squeda local...');
            this.performLocalSearch();
          } else {
            console.error('Error del servidor en b√∫squeda, intentando b√∫squeda local...');
            this.performLocalSearch();
          }
        }
      });
  }

  // B√∫squeda local como fallback
  private performLocalSearch() {
    console.log('=== INICIANDO B√öSQUEDA LOCAL (FALLBACK) ===');
    
    if (!this.books || this.books.length === 0) {
      console.log('No hay libros cargados para b√∫squeda local');
      this.searchResults = [];
      return;
    }

    const searchTerm = this.searchTitle.toLowerCase().trim();
    console.log('Buscando localmente:', searchTerm);

    // B√∫squeda m√°s flexible: t√≠tulo, autor, a√±o
    const localResults = this.books.filter(book => {
      const titleMatch = book.title.toLowerCase().includes(searchTerm);
      const authorMatch = book.author.toLowerCase().includes(searchTerm);
      const yearMatch = book.publicationYear.toString().includes(searchTerm);
      
      return titleMatch || authorMatch || yearMatch;
    });

    console.log(`üîç B√∫squeda local completada: ${localResults.length} resultados encontrados`);
    this.searchResults = localResults;
  }

  // M√©todo para b√∫squeda en tiempo real
  onSearchInputChange() {
    // Limpiar b√∫squeda anterior si el campo est√° vac√≠o
    if (!this.searchTitle.trim()) {
      this.searchResults = [];
      this.isSearching = false;
      return;
    }

    // B√∫squeda local en tiempo real para mejor UX
    console.log('üîç B√∫squeda en tiempo real:', this.searchTitle);
    this.performLocalSearch();
  }

  // M√©todo para b√∫squeda con Enter
  onSearchKeyPress(event: any) {
    if (event.key === 'Enter') {
      console.log('üîç Enter presionado, ejecutando b√∫squeda local...');
      this.performLocalSearch();
    }
  }

  // M√©todo para limpiar b√∫squeda
  clearSearch() {
    console.log('=== LIMPIANDO B√öSQUEDA ===');
    
    this.searchTitle = '';
    this.searchResults = [];
    this.isSearching = false;
    
    console.log('‚úÖ B√∫squeda limpiada completamente');
  }

  // M√©todo para obtener libros a mostrar (b√∫squeda o filtro normal)
  getBooksToShow(): Book[] {
    // Si hay t√©rmino de b√∫squeda y resultados de b√∫squeda
    if (this.searchTitle.trim() && this.searchResults.length > 0) {
      console.log('‚úÖ Mostrando resultados de b√∫squeda:', this.searchResults.length, 'libros');
      return this.searchResults;
    }
    
    // Si hay t√©rmino de b√∫squeda pero no hay resultados
    if (this.searchTitle.trim() && this.searchResults.length === 0) {
      console.log('‚ö†Ô∏è Hay t√©rmino de b√∫squeda pero no hay resultados');
      return [];
    }
    
    // Si no hay t√©rmino de b√∫squeda, mostrar filtros normales
    console.log('‚úÖ Mostrando filtros normales:', this.filteredBooks.length, 'libros');
    return this.filteredBooks;
  }

  // M√©todo para verificar si estamos mostrando resultados de b√∫squeda
  isShowingSearchResults(): boolean {
    const showingSearch = this.searchTitle.trim() !== '' && this.searchResults.length > 0;
    console.log('üîç Mostrando resultados de b√∫squeda:', showingSearch);
    return showingSearch;
  }
}